#!/usr/bin/env bash
# doc: Rozděluje soubor na části po řádcích round-robin způsobem

# Source basic functions
source "$HOME/bin/basic-func.sh" || { echo "Failed to source basic-func.sh"; exit 1; }

# Default values
PARTS=2
OUTPUT_DIR="$(pwd)"
INPUT_FILE=""

# Function to show usage
show_usage() {
    echo "Usage: $0 <filename> [--parts <digit>] [--dir <path>]"
    echo "       $0 <filename> [--parts <digit>] [<output_dir>]"
    echo ""
    echo "  <filename>      Input file to split (required)"
    echo "  --parts <digit> Number of parts to split into (default: 2)"
    echo "  --dir <path>    Output directory (default: current directory)"
    echo "  <output_dir>    Output directory as positional argument (alternative to --dir)"
    echo ""
    echo "Examples:"
    echo "  $0 file.txt --parts 3 --dir /tmp"
    echo "  $0 file.txt --parts 3 /tmp"
    echo "  $0 file.txt --parts 3 ."
    exit 1
}

# Parse command line arguments
positional_args=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --parts)
            [[ -z "$2" ]] && fdie "--parts requires a value"
            PARTS="$2"
            shift 2
            ;;
        --dir)
            [[ -z "$2" ]] && fdie "--dir requires a value"
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --help|-h)
            show_usage
            ;;
        -*)
            fdie "Unknown option: $1"
            ;;
        *)
            positional_args+=("$1")
            shift
            ;;
    esac
done

# Process positional arguments
if [[ ${#positional_args[@]} -eq 0 ]]; then
    fdie "Input filename is required"
elif [[ ${#positional_args[@]} -eq 1 ]]; then
    INPUT_FILE="${positional_args[0]}"
elif [[ ${#positional_args[@]} -eq 2 ]]; then
    INPUT_FILE="${positional_args[0]}"
    # Only set OUTPUT_DIR if it wasn't already set by --dir
    if [[ "$OUTPUT_DIR" == "$(pwd)" ]]; then
        OUTPUT_DIR="${positional_args[1]}"
    else
        fdie "Cannot specify both --dir and positional output directory"
    fi
else
    fdie "Too many positional arguments. Expected: <filename> [<output_dir>]"
fi

# Validate parameters
[[ -z "$INPUT_FILE" ]] && fdie "Input filename is required"
[[ ! -f "$INPUT_FILE" ]] && fdie "Input file does not exist: $INPUT_FILE"
[[ ! "$PARTS" =~ ^[0-9]+$ ]] && fdie "Parts must be a positive integer: $PARTS"
[[ "$PARTS" -lt 1 ]] && fdie "Parts must be at least 1: $PARTS"
[[ ! -d "$OUTPUT_DIR" ]] && fdie "Output directory does not exist: $OUTPUT_DIR"
[[ ! -w "$OUTPUT_DIR" ]] && fdie "Output directory is not writable: $OUTPUT_DIR"

# Get base filename without path
BASE_NAME=$(basename "$INPUT_FILE")

flog "Splitting file '$INPUT_FILE' into $PARTS parts" info
flog "Output directory: $OUTPUT_DIR" info
flog "Base filename: $BASE_NAME" info

# Read input file line by line and distribute round-robin
# For better performance with large files, use awk instead of bash loop
flog "Using awk for efficient processing of large files" info

awk -v parts="$PARTS" -v base_dir="$OUTPUT_DIR" -v base_name="$BASE_NAME" '
BEGIN {
    # Initialize output file paths
    for (i = 1; i <= parts; i++) {
        output_files[i] = base_dir "/" base_name "_part" i
        # Clear output files
        print "" > output_files[i]
        close(output_files[i])
    }
}
{
    # Calculate which part this line belongs to (1-based)
    part_index = ((NR - 1) % parts) + 1
    
    # Write line to appropriate part file
    print $0 >> output_files[part_index]
}
END {
    # Close all files and print summary
    for (i = 1; i <= parts; i++) {
        close(output_files[i])
    }
    printf "Processed %d lines\n", NR > "/dev/stderr"
}' "$INPUT_FILE"

total_lines=$(wc -l < "$INPUT_FILE")
flog "Processed $total_lines lines" info

# Show summary
for ((i=1; i<=PARTS; i++)); do
    part_file="$OUTPUT_DIR/${BASE_NAME}_part${i}"
    part_lines=$(wc -l < "$part_file")
    flog "Part $i: $part_file ($part_lines lines)" info
done

flog "File splitting completed successfully" info