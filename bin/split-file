#!/usr/bin/env bash
# doc: Rozděluje soubor na části po řádcích round-robin způsobem

[ "$(type -t include)" != 'function' ]&&{ include(){ { [ -z "$_IR" ]&&_IR="$PWD"&&cd "$(dirname "${BASH_SOURCE[0]}")"&&include "$1"&&cd "$_IR"&&unset _IR;}||{ local d="$PWD"&&cd "$(dirname "$PWD/$1")"&&. "$(basename "$1")"&&cd "$d";}||{ echo "Include failed $PWD->$1"&&exit 1;};};}
include "lib/user_io.sh"
include "lib/die.sh"

# Default values
PARTS=2
OUTPUT_DIR="$(pwd)"
INPUT_FILE=""

# Function to show usage
show_usage() {
    echo "Usage: $0 <filename> [--parts <digit>] [--dir <path>]"
    echo "       $0 <filename> [--parts <digit>] [<output_dir>]"
    echo ""
    echo "  <filename>      Input file to split (required)"
    echo "  --parts <digit> Number of parts to split into (default: 2)"
    echo "  --dir <path>    Output directory (default: current directory)"
    echo "  <output_dir>    Output directory as positional argument (alternative to --dir)"
    echo ""
    echo "Examples:"
    echo "  $0 file.txt --parts 3 --dir /tmp"
    echo "  $0 file.txt --parts 3 /tmp"
    echo "  $0 file.txt --parts 3 ."
    exit 1
}

# Parse command line arguments
positional_args=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --parts)
            [[ -z "$2" ]] && fDie "--parts requires a value"
            PARTS="$2"
            shift 2
            ;;
        --dir)
            [[ -z "$2" ]] && fDie "--dir requires a value"
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --help|-h)
            show_usage
            ;;
        -*)
            fDie "Unknown option: $1"
            ;;
        *)
            positional_args+=("$1")
            shift
            ;;
    esac
done

# Process positional arguments
if [[ ${#positional_args[@]} -eq 0 ]]; then
    fDie "Input filename is required"
elif [[ ${#positional_args[@]} -eq 1 ]]; then
    INPUT_FILE="${positional_args[0]}"
elif [[ ${#positional_args[@]} -eq 2 ]]; then
    INPUT_FILE="${positional_args[0]}"
    # Only set OUTPUT_DIR if it wasn't already set by --dir
    if [[ "$OUTPUT_DIR" == "$(pwd)" ]]; then
        OUTPUT_DIR="${positional_args[1]}"
    else
        fDie "Cannot specify both --dir and positional output directory"
    fi
else
    fDie "Too many positional arguments. Expected: <filename> [<output_dir>]"
fi

# Validate parameters
[[ -z "$INPUT_FILE" ]] && fDie "Input filename is required"
[[ ! -f "$INPUT_FILE" ]] && fDie "Input file does not exist: $INPUT_FILE"
[[ ! "$PARTS" =~ ^[0-9]+$ ]] && fDie "Parts must be a positive integer: $PARTS"
[[ "$PARTS" -lt 1 ]] && fDie "Parts must be at least 1: $PARTS"
[[ ! -d "$OUTPUT_DIR" ]] && fDie "Output directory does not exist: $OUTPUT_DIR"
[[ ! -w "$OUTPUT_DIR" ]] && fDie "Output directory is not writable: $OUTPUT_DIR"

# Get base filename without path
BASE_NAME=$(basename "$INPUT_FILE")

printInfo "Splitting file '$INPUT_FILE' into $PARTS parts" 
printInfo "Output directory: $OUTPUT_DIR"
printInfo "Base filename: $BASE_NAME"

awk -v parts="$PARTS" -v base_dir="$OUTPUT_DIR" -v base_name="$BASE_NAME" '
BEGIN {
    # Initialize output file paths
    for (i = 1; i <= parts; i++) {
        output_files[i] = base_dir "/" base_name "_part" i
        # Clear output files (without writing empty line)
        printf "" > output_files[i]
        close(output_files[i])
    }
}
{
    # Calculate which part this line belongs to (1-based)
    part_index = ((NR - 1) % parts) + 1
    
    # Write line to appropriate part file
    print $0 >> output_files[part_index]
}
END {
    # Close all files and print summary
    for (i = 1; i <= parts; i++) {
        close(output_files[i])
    }
    printf "Processed %d lines\n", NR > "/dev/stderr"
}' "$INPUT_FILE"

total_lines=$(wc -l < "$INPUT_FILE")
printSuccess "Processed $total_lines lines"

# Show summary
for ((i=1; i<=PARTS; i++)); do
    part_file="$OUTPUT_DIR/${BASE_NAME}_part${i}"
    part_lines=$(wc -l < "$part_file")
    printSuccess "Part $i: $part_file ($part_lines lines)" info
done