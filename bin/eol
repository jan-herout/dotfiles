#!/usr/bin/env bash
# doc: Convert End-Of-Line characters in files between Unix (LF) and Windows (CRLF)

# Script to convert end-of-line characters in files
# Usage: convert-eol <filename> [--eol <cr|lf|crlf>]
set -e
set -o pipefail

show_usage() {
    echo "Synopsis: converts EOL characters in a file via sed"
    echo "Usage: "
    echo "  $0 <filename> [<cr|lf|crlf>]"
    echo "  $0 <filename> [-e <cr|lf|crlf>]"
    echo "  $0 <filename> [--eol <cr|lf|crlf>]"    
    echo ""
    echo "Arguments:"
    echo "  filename    File to convert"
    echo "  --eol       End-of-line format (cr, lf, or crlf)"
    echo ""
    echo "If --eol is not provided, you will be prompted to select one using fzf"
    exit 1
}

# Detect current EOL format efficiently
detect_eol() {
    local file="$1"
    local sample_size=10000 # 10kB sample
    
    # Get file size for optimization
    local file_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
    
    if [ "$file_size" -eq 0 ]; then
        echo "unknown"
        return
    fi
    
    # For large files, only sample the first part
    local sample_data
    if [ "$file_size" -gt "$sample_size" ]; then
        sample_data=$(head -c "$sample_size" "$file")
    else
        sample_data=$(cat "$file")
    fi
    
    # Check for CRLF first (most specific) - use built-in pattern matching
    if [[ "$sample_data" == *$'\r\n'* ]]; then
        echo "crlf"
        return
    fi
    
    # Check for CR only (old Mac)
    if [[ "$sample_data" == *$'\r'* ]]; then
        echo "cr"
        return
    fi
    
    # If we have content, assume LF
    echo "lf"
}


# Check if filename is provided
if [ -z "$1" ]; then
    echo "Error: Filename is required"
    show_usage
fi

filename="$1"

# Check if file exists
if [ ! -f "$filename" ]; then
    echo "Error: File '$filename' does not exist"
    exit 1
fi

# Parse EOL argument
eol=""
if [[ "$2" = "--eol" ]] || [[ "$2" == "-e" ]] && [ -n "$3" ]; then
    case "$3" in
        cr|lf|crlf)
            eol="$3"
            ;;
        *)
            echo "Error: Invalid EOL format '$3'. Must be cr, lf, or crlf"
            show_usage
            ;;
    esac
fi

case "$2" in
    CR|cr)
        eol="cr"
        ;;
    LF|lf)
        eol="lf"
        ;;
    CRLF|crlf)
        eol="crlf"
        ;;
esac

# Detect current EOL format
current_eol=$(detect_eol "$filename")
echo "Current EOL format: $current_eol"


# If EOL not provided, use fzf to select
if [ -z "$eol" ]; then
    # Check if fzf is available
    if ! command -v fzf  &> /dev/null; then
        echo "Error: fzf is required but not installed"
        exit 1
    fi
    
    echo "New format?"
    eol=$(echo -e "lf\ncrlf\ncr" | fzf --height=5)    
fi

if [ -z "$eol" ]; then
        echo "Error: No EOL format selected"
        show_usage
        exit 1
fi

echo "Target EOL format: $eol"

# Check if conversion is needed
if [ "$current_eol" = "$eol" ]; then
    echo "Warning: File '$filename' already uses $eol format. No conversion needed."
    exit 0
fi

if [ "$current_eol" = "unknown" ]; then
    echo "Warning: Unable to detect current EOL format (file might be empty or binary)"
    read -p "Continue anyway? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Conversion cancelled"
        exit 1
    fi
fi

echo "Converting '$filename' from $current_eol to $eol format..."

# Get file size for progress indication
file_size=$(stat -c%s "$filename" 2>/dev/null || echo 0)
if [ "$file_size" -gt 10485760 ]; then  # 10MB
    echo "Large file detected ($(numfmt --to=iec "$file_size")). This may take a moment..."
fi

# Perform the conversion using efficient tools
case "$eol" in
    "lf")
        # Convert to LF (Unix style) - use tr for better performance
        tr -d '\r' < "$filename" > "${filename}.tmp" && mv "${filename}.tmp" "$filename"
        echo "Converted to LF (Unix) format"
        ;;
    "crlf")
        # Convert to CRLF (Windows style) - two-step process for safety
        # First ensure we have LF only, then convert to CRLF
        tr -d '\r' < "$filename" > "${filename}.tmp"
        awk '{printf "%s\r\n", $0}' "${filename}.tmp" > "$filename"
        rm "${filename}.tmp"
        echo "Converted to CRLF (Windows) format"
        ;;
    "cr")
        # Convert to CR (Old Mac style)
        tr -d '\r' < "$filename" | tr '\n' '\r' > "${filename}.tmp" && mv "${filename}.tmp" "$filename"
        echo "Converted to CR (old Mac) format"
        ;;
esac

echo "Conversion completed successfully"