#!/usr/bin/env bash
ME=$(basename "$0")
USAGE=$(cat <<EOF
Synopsis: Search my wiki for cheats
Usage:
    $ME <tag> - display list of all cheats and let me select a cheat, then echo the cheat
    $ME -a [filename] - add a new content to a cheat sheet; uses fzf to selected a file if not povided
    $ME -n [filename] - create a new cheatsheet under the WIKI_ROOT
    $ME -d - open today's daily note (YYYY-MM-DD.md in journal/)
    $ME -b - build hashtag backlinks (create tag files with links to all files containing each hashtag)

EOF
)

ARG_ADD="" # -a
ARG_NEW="" # -n
ARG_DAILY="" # -d
ARG_BACKLINKS="" # -b
while getopts "handb" opt; do
   case "${opt}" in
       h)
           echo $USAGE
           exit 0
           ;;
        a)
            ARG_ADD="${OPTARG}"
            [[ -z "$ARG_ADD" ]] && ARG_ADD="."
            ;;
        n)

            ARG_NEW="${OPTARG}"
            [[ -z "$ARG_NEW" ]] && ARG_ADD="."
            ;;
        d)
            ARG_DAILY="true"
            ;;
        b)
            ARG_BACKLINKS="true"
            ;;
        ?)
            echo $USAGE
            exit 0
            ;;
    esac
done
shift $((OPTIND - 1))



DEPENDENCIES=(
    rg
    fzf
    nvim
    xclip
)
for cmd in "${DEPENDENCIES[@]}"; do
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: $cmd is required but not installed"
        exit 1
    fi
done


WIKI_ROOT=$HOME/dotfiles/cheat.sheet
TO_CLIPBOARD="xclip -selection clipboard"

# Rules:
# - list all files under the WIKI_ROOT_HOME
# - use ripgrep to find all lines that start with "minus" sign and that contain the tag
# - pipe the list of files and lines to the fzf to select one
# - get filename and the line from this selection
# - from the filename, read everything starting with the line obtained from fzf until the next line that starts with minus
# - print out the content
function ask_cheats() {
    local tag="$1"
    
    # Check if tag is provided
    if [[ -z "$tag" ]]; then
        echo "Error: Please provide a tag to search for"
        echo "$USAGE" 
        exit 1
    fi
    
    # Find all lines that start with "-" and contain the tag
    local selection
    selection=$(rg "^-.*$tag" "$WIKI_ROOT" --line-number --with-filename | fzf --prompt "tag: $tag" --delimiter=':' --preview='
        file={1}
        line={2}
        awk -v start="$line" "
            NR >= start {
                if (NR == start || !/^-/) {
                    print
                } else {
                    exit
                }
            }
        " "$file" | batcat --language=markdown
    ')
    
    # Check if user made a selection
    if [[ -z "$selection" ]]; then
        echo "No selection made"
        exit 0
    fi
    
    # Extract filename and line number
    local filename=$(echo "$selection" | cut -d':' -f1)
    local line_number=$(echo "$selection" | cut -d':' -f2)
    
    # Extract and display the cheat
    $cheat=$(awk -v start="$line_number" '
        NR >= start {
            if (NR == start || !/^-/) {
                print
            } else {
                exit
            }
        }
    ' "$filename")

    to_clipboard=$(printf "yes\nno" | fzf --prompt "OdloÅ¾it do clipboardu?")
    [[ $to_clipboard == "yes" ]] && echo "$cheat" | $TO_CLIPBOARD
    echo $TO_CLIPBOARD

}

function add_cheat() {
    local filename="$1"
    
    if [[ "$filename" == "." ]]; then 
        # Find all files under WIKI_ROOT
        local selected_file
        selected_file=$(find "$WIKI_ROOT" -type f \( -name "*.wiki" -o -name "*.md" \) | fzf --preview='cat {}' --preview-window=right:70%:wrap)
        
        # Check if user made a selection
        if [[ -z "$selected_file" ]]; then
            echo "No file selected"
            exit 0
        fi
    else
        selected_file="$WIKI_ROOT/$filename"
    fi

    if [[ ! -f "$selected_file" ]]; then
        echo "file does not exist: $selected_file"
        exit 1
    fi
    
    # Open the selected file in vim
    #
    nvim "$selected_file"
}

function new_cheat() {
    local arg_filename="$1"
    local filename=""

    if [[ "$arg_filename" == "." ]]; then
        # Ask for the filename
        echo -n "Enter the name for the new cheatsheet (without .wiki extension): "
        read -r filename
    else
        filename="$arg_filename"
    fi
    
    # Check if filename was provided
    if [[ -z "$filename" ]]; then
        echo "Error: Filename cannot be empty"
        exit 1
    fi
    
    # Sanitize filename (remove special characters, replace spaces with underscores)
    filename=$(echo "$filename" | sed 's/[^a-zA-Z0-9_-]/_/g')
    
    # Add .wiki extension if not present
    if [[ ! "$filename" =~ \.wiki$ ]]; then
        filename="${filename}.wiki"
    fi
    
    # Create the full path
    local new_file_path="$WIKI_ROOT/$filename"
    
    # Check if file already exists
    if [[ -f "$new_file_path" ]]; then
        echo -n "File '$filename' already exists. Do you want to open it anyway? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled"
            exit 0
        fi
    fi
    
    # Create the file with a basic template if it doesn't exist
    if [[ ! -f "$new_file_path" ]]; then
        cat > "$new_file_path" << 'EOF'
-   #tag #example
    Description of the cheat goes here
    ```bash
    # Example command
    echo "Hello World"
    ```

EOF
        echo "Created new cheatsheet: $filename"
    fi
    
    # Open the file in vim
    nvim "$new_file_path"
}

function daily_note() {
    # Get current date in YYYY-MM-DD format
    local today=$(date +%Y-%m-%d)
    local journal_dir="$WIKI_ROOT/journal"
    local daily_file="$journal_dir/$today.md"
    
    # Create journal directory if it doesn't exist
    if [[ ! -d "$journal_dir" ]]; then
        mkdir -p "$journal_dir"
    fi
    
    # Create the daily note file if it doesn't exist
    if [[ ! -f "$daily_file" ]]; then
        cat > "$daily_file" << EOF
# Daily Note - $today

EOF
        echo "Created daily note: $today.md"
    fi
    
    # Open the file in nvim
    nvim "$daily_file"
}

function build_backlinks() {
    local tags_dir="$WIKI_ROOT/tags"
    
    # Create tags directory if it doesn't exist
    if [[ ! -d "$tags_dir" ]]; then
        mkdir -p "$tags_dir"
    fi
    
    echo "Building hashtag backlinks..."
    
    # Find all .md and .wiki files under WIKI_ROOT, excluding the tags directory
    local md_files
    md_files=$(find "$WIKI_ROOT" -type f \( -name "*.md" -o -name "*.wiki" \) -not -path "$tags_dir/*")
    
    # Check if any files were found
    if [[ -z "$md_files" ]]; then
        echo "No .md or .wiki files found in $WIKI_ROOT"
        return 1
    fi
    
    # Count and print all found files for debugging
    local file_count=$(echo "$md_files" | wc -l)
    echo "Found $file_count files:"
    echo "$md_files"
    echo ""
 
    # Collect all unique hashtags
    local all_hashtags
    all_hashtags=$(echo "$md_files" | xargs grep -h '#[a-zA-Z0-9_-]\+' -o | sort -u)
    
    # Process each hashtag
    while IFS= read -r hashtag; do
        [[ -z "$hashtag" ]] && continue
        
        # Remove the # sign from hashtag for filename
        local tag_name="${hashtag#\#}"
        local hashtag_file="$tags_dir/$tag_name.md"
        
        echo "Processing hashtag: $hashtag"
        
        # Create/overwrite the hashtag file
        [[ -f "$hashtag_file" ]] && rm "$hashtag_file"
        cat > "$hashtag_file" << EOF
# Tag: $hashtag

Backlinks to files containing this hashtag:

EOF
        
        # Find all files containing this hashtag and create backlinks
        local found_files
        found_files=$(echo "$md_files" | xargs grep -l "$hashtag")
        
        while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            
            # Get relative path from WIKI_ROOT
            local rel_path="${file#$WIKI_ROOT/}"
            
            # Find lines containing the hashtag and get first 60 chars as link text
            local hashtag_lines
            hashtag_lines=$(grep -n "$hashtag" "$file")
            
            while IFS= read -r line_info; do
                [[ -z "$line_info" ]] && continue
                
                local line_number=$(echo "$line_info" | cut -d':' -f1)
                local line_content=$(echo "$line_info" | cut -d':' -f2-)
                
                # Get first 60 characters of the line for link text
                local link_text="${line_content:0:60}"
                [[ ${#line_content} -gt 60 ]] && link_text="${link_text}..."
                
                # Write the backlink in markdown format
                # Calculate relative path from hashtag file to target file
                local hashtag_rel_path="$rel_path"
                echo "- [$link_text]($hashtag_rel_path) (line $line_number)" >> "$hashtag_file"
                
            done <<< "$hashtag_lines"
            
        done <<< "$found_files"
        echo "" >> "$hashtag_file"
        
    done <<< "$all_hashtags"
    
    echo "Hashtag backlinks built successfully in $tags_dir"
}


# Main script logic
if [[ ! -z "$ARG_ADD" ]]; then
    add_cheat "$ARG_ADD"
    exit 0
fi

if [[ ! -z "$ARG_NEW" ]]; then
    new_chet "$ARG_NEW"
    exit 0
fi

if [[ ! -z "$ARG_DAILY" ]]; then
    daily_note
    exit 0
fi

if [[ ! -z "$ARG_BACKLINKS" ]]; then
    build_backlinks
    exit 0
fi

# default command
ask_cheats "$1"
