#!/bin/bash

# doc: Copies files and directories from source to destination, treating paths as case-insensitive
# Supports: -n (dry-run), -v (verbose), -a (preserve attrs via cp -a),
#           -i (prompt before overwrite), -x PATTERN (exclude; repeatable),
#           -h/--help (usage)
set -euo pipefail
trap 'echo "Error at line $LINENO while running: $BASH_COMMAND" >&2' ERR

DRY_RUN=0
VERBOSE=0
PRESERVE_ATTRS=0
PROMPT_OVERWRITE=0
declare -a EXCLUDES=()

print_usage() {
        cat <<EOF
Usage: icp [options] <source> <dest>

Copies files/dirs case-insensitively, preserving destination casing when present.

Options:
    -n              Dry-run (show actions without changing files)
    -v              Verbose output
    -a              Preserve attributes (cp -a)
    -i              Prompt before overwriting existing files
    -x PATTERN      Exclude relative paths matching shell pattern (repeatable)
    -h, --help      Show this help

Examples:
    icp src.txt /tmp/target
    icp -nva ./src_dir ~/dest_dir
    icp -x "*.log" -x "cache/*" ./src ./dest
EOF
}

log() {
    if [ "$VERBOSE" -eq 1 ] || [ "$DRY_RUN" -eq 1 ]; then
        echo "$@"
    fi
}

# True if STDIN is a terminal (interactive session)
is_interactive() {
    [ -t 0 ]
}

is_excluded() {
    local rel="$1"
    local saved_shopt
    saved_shopt=$(shopt -p nocasematch || true)
    shopt -s nocasematch
    for pat in "${EXCLUDES[@]}"; do
        if [[ "$rel" == $pat ]]; then
            eval "$saved_shopt" || true
            return 0
        fi
    done
    eval "$saved_shopt" || true
    return 1
}

# Basic long option handling for common flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help)
            print_usage
            exit 0
            ;;
        --dry-run)
            DRY_RUN=1; shift; continue ;;
        --verbose)
            VERBOSE=1; shift; continue ;;
        --preserve|--attrs)
            PRESERVE_ATTRS=1; shift; continue ;;
        --interactive)
            PROMPT_OVERWRITE=1; shift; continue ;;
        --exclude=*)
            EXCLUDES+=("${1#*=}"); shift; continue ;;
        --)
            shift; break ;;
        -*)
            break ;;
        *)
            break ;;
    esac
done

while getopts ":nvaix:h" opt; do
    case "$opt" in
        n) DRY_RUN=1 ;;
        v) VERBOSE=1 ;;
        a) PRESERVE_ATTRS=1 ;;
        i) PROMPT_OVERWRITE=1 ;;
        x) EXCLUDES+=("$OPTARG") ;;
        h) print_usage; exit 0 ;;
        :) echo "Error: Option -$OPTARG requires an argument" >&2; exit 1 ;;
        \?) echo "Error: Unknown option -$OPTARG" >&2; print_usage; exit 1 ;;
    esac
done
shift $((OPTIND - 1))

# Check positional args
if [ $# -ne 2 ]; then
    echo "Error: Incorrect number of arguments." >&2
    print_usage
    exit 1
fi

SOURCE="$1"
DEST="$2"

# Verify source exists
if [ ! -e "$SOURCE" ]; then
    echo "Error: Source '$SOURCE' does not exist"
    exit 1
fi

# Check if source is a file
if [ -f "$SOURCE" ]; then
    # Source is a file
    SOURCE_FILE="$(realpath "$SOURCE")"
    SOURCE_FILENAME="$(basename "$SOURCE")"

    # Create destination directory if it doesn't exist
    if [ "$DRY_RUN" -eq 1 ]; then
        log "Would ensure dir: $DEST"
    else
        mkdir -p "$DEST"
    fi
    DEST="$(cd "$DEST" && pwd)"

    # Exclusions
    if is_excluded "$SOURCE_FILENAME"; then
        log "Excluded file: $SOURCE_FILENAME"
        exit 0
    fi

    # Check if file exists (case-insensitively) in destination
    mapfile -t matches < <(find "$DEST" -maxdepth 1 -iname "$SOURCE_FILENAME" -print 2>/dev/null | LC_ALL=C sort)
    existing_target=""
    if [ ${#matches[@]} -gt 0 ]; then
        existing_target="${matches[0]}"
        if [ ${#matches[@]} -gt 1 ]; then
            echo "Warning: Multiple case-insensitive matches for '$SOURCE_FILENAME' in '$DEST'. Using: $existing_target" >&2
        fi
    fi

    CP_BASE=(cp)
    if [ "$PRESERVE_ATTRS" -eq 1 ]; then CP_BASE+=("-a"); fi

    if [ -n "$existing_target" ]; then
        # File exists (case-insensitively), potential overwrite
        if [ "$PROMPT_OVERWRITE" -eq 1 ]; then
            if [ "$DRY_RUN" -eq 1 ]; then
                log "Would prompt overwrite: $existing_target"
            elif is_interactive; then
                read -r -p "Overwrite '$existing_target'? [y/N] " ans < /dev/tty
                case "$ans" in
                    y|Y|yes|YES) : ;; 
                    *) echo "Skipped overwrite: $existing_target"; exit 0 ;;
                esac
            else
                echo "Non-interactive (stdin not a tty); skipped overwrite: $existing_target"
                exit 0
            fi
        fi
        if [ "$DRY_RUN" -eq 1 ]; then
            log "Would copy (overwrite): $SOURCE_FILE -> $existing_target"
        else
            "${CP_BASE[@]}" -f "$SOURCE_FILE" "$existing_target"
            echo "Copy completed: $SOURCE_FILE -> $existing_target"
        fi
    else
        # File doesn't exist, copy with source's case
        target_path="$DEST/$SOURCE_FILENAME"
        if [ "$DRY_RUN" -eq 1 ]; then
            log "Would copy: $SOURCE_FILE -> $target_path"
        else
            "${CP_BASE[@]}" "$SOURCE_FILE" "$target_path"
            echo "Copy completed: $SOURCE_FILE -> $target_path"
        fi
    fi

    exit 0
fi

# Source is a directory
# Create destination directory if it doesn't exist
mkdir -p "$DEST"

# Convert paths to absolute paths
SOURCE="$(cd "$SOURCE" && pwd)"
DEST="$(cd "$DEST" && pwd)"

# Function to find case-insensitive match in target
# Returns the actual path if found, empty string otherwise
find_case_insensitive() {
    local target_base="$1"
    local relative_path="$2"
    
    # Split the relative path into components
    local current_dir="$target_base"
    local IFS='/'
    local path_parts=($relative_path)
    local found_path=""
    
    for part in "${path_parts[@]}"; do
        if [ -z "$part" ]; then
            continue
        fi
        
        # Look for case-insensitive match in current directory
        local match=""
        if [ -d "$current_dir" ]; then
            # Use find to do case-insensitive search in current directory only
            match=$(find "$current_dir" -maxdepth 1 -iname "$part" -print -quit 2>/dev/null)
        fi
        
        if [ -n "$match" ]; then
            current_dir="$match"
            found_path="$match"
        else
            # No match found, return empty
            return 1
        fi
    done
    
    echo "$found_path"
    return 0
}

# Process all files and directories under source
cd "$SOURCE"

# First, process directories
while IFS= read -r -d '' item; do
    relative_path="${item#./}"
    [ "$relative_path" = "." ] && continue
    is_excluded "$relative_path" && { log "Excluded dir: $relative_path"; continue; }

    source_item="$SOURCE/$relative_path"
    target_item="$DEST/$relative_path"
    existing_target=$(find_case_insensitive "$DEST" "$relative_path" || echo "")

    if [ -n "$existing_target" ]; then
        log "Using existing directory: $existing_target"
    else
        if [ "$DRY_RUN" -eq 1 ]; then
            log "Would create dir: $target_item"
        else
            mkdir -p "$target_item"
            log "Created dir: $target_item"
        fi
    fi
done < <(find . -type d -print0)

# Then, process files
while IFS= read -r -d '' item; do
    relative_path="${item#./}"
    [ "$relative_path" = "." ] && continue
    is_excluded "$relative_path" && { log "Excluded file: $relative_path"; continue; }

    source_item="$SOURCE/$relative_path"
    target_item="$DEST/$relative_path"
    existing_target=$(find_case_insensitive "$DEST" "$relative_path" || echo "")

    CP_BASE=(cp)
    if [ "$PRESERVE_ATTRS" -eq 1 ]; then CP_BASE+=("-a"); fi

    if [ -n "$existing_target" ]; then
        if [ "$PROMPT_OVERWRITE" -eq 1 ]; then
            if [ "$DRY_RUN" -eq 1 ]; then
                log "Would prompt overwrite: $existing_target"
            elif is_interactive; then
                read -r -p "Overwrite '$existing_target'? [y/N] " ans < /dev/tty
                case "$ans" in
                    y|Y|yes|YES) : ;;
                    *) log "Skipped overwrite: $existing_target"; continue ;;
                esac
            else
                log "Non-interactive (stdin not a tty); skipped overwrite: $existing_target"
                continue
            fi
        fi
        if [ "$DRY_RUN" -eq 1 ]; then
            log "Would copy (overwrite): $source_item -> $existing_target"
        else
            "${CP_BASE[@]}" -f "$source_item" "$existing_target"
            log "Copied: $source_item -> $existing_target"
        fi
    else
        target_dir="$(dirname "$target_item")"
        parent_relative="$(dirname "$relative_path")"
        if [ "$parent_relative" != "." ]; then
            existing_parent=$(find_case_insensitive "$DEST" "$parent_relative" || echo "")
            if [ -n "$existing_parent" ]; then
                filename="$(basename "$target_item")"
                target_item="$existing_parent/$filename"
            else
                if [ "$DRY_RUN" -eq 1 ]; then
                    log "Would ensure dir: $target_dir"
                else
                    mkdir -p "$target_dir"
                fi
            fi
        fi
        if [ "$DRY_RUN" -eq 1 ]; then
            log "Would copy: $source_item -> $target_item"
        else
            "${CP_BASE[@]}" "$source_item" "$target_item"
            log "Copied: $source_item -> $target_item"
        fi
    fi
done < <(find . -type f -print0)

if [ "$DRY_RUN" -eq 1 ]; then
    echo "Dry-run completed: $SOURCE -> $DEST"
else
    echo "Copy completed: $SOURCE -> $DEST"
fi
