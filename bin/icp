#!/bin/bash

# icp - Case-insensitive copy script
# Copies files and directories from source to destination, treating paths as case-insensitive

set -e

# Check if we have exactly 2 arguments
if [ $# -ne 2 ]; then
    echo "Usage: icp <source> <dest>"
    exit 1
fi

SOURCE="$1"
DEST="$2"

# Verify source exists
if [ ! -e "$SOURCE" ]; then
    echo "Error: Source '$SOURCE' does not exist"
    exit 1
fi

# Check if source is a file
if [ -f "$SOURCE" ]; then
    # Source is a file
    SOURCE_FILE="$(realpath "$SOURCE")"
    SOURCE_FILENAME="$(basename "$SOURCE")"
    
    # Create destination directory if it doesn't exist
    mkdir -p "$DEST"
    DEST="$(cd "$DEST" && pwd)"
    
    # Check if file exists (case-insensitively) in destination
    existing_target=$(find "$DEST" -maxdepth 1 -iname "$SOURCE_FILENAME" -print -quit 2>/dev/null || echo "")
    
    if [ -n "$existing_target" ]; then
        # File exists (case-insensitively), overwrite it (keeping target's case)
        cp -f "$SOURCE_FILE" "$existing_target"
        echo "Copy completed: $SOURCE_FILE -> $existing_target"
    else
        # File doesn't exist, copy with source's case
        cp "$SOURCE_FILE" "$DEST/$SOURCE_FILENAME"
        echo "Copy completed: $SOURCE_FILE -> $DEST/$SOURCE_FILENAME"
    fi
    
    exit 0
fi

# Source is a directory
# Create destination directory if it doesn't exist
mkdir -p "$DEST"

# Convert paths to absolute paths
SOURCE="$(cd "$SOURCE" && pwd)"
DEST="$(cd "$DEST" && pwd)"

# Function to find case-insensitive match in target
# Returns the actual path if found, empty string otherwise
find_case_insensitive() {
    local target_base="$1"
    local relative_path="$2"
    
    # Split the relative path into components
    local current_dir="$target_base"
    local IFS='/'
    local path_parts=($relative_path)
    local found_path=""
    
    for part in "${path_parts[@]}"; do
        if [ -z "$part" ]; then
            continue
        fi
        
        # Look for case-insensitive match in current directory
        local match=""
        if [ -d "$current_dir" ]; then
            # Use find to do case-insensitive search in current directory only
            match=$(find "$current_dir" -maxdepth 1 -iname "$part" -print -quit 2>/dev/null)
        fi
        
        if [ -n "$match" ]; then
            current_dir="$match"
            found_path="$match"
        else
            # No match found, return empty
            return 1
        fi
    done
    
    echo "$found_path"
    return 0
}

# Process all files and directories under source
cd "$SOURCE"

# Use find to get all files and directories, sorted by depth (directories first)
while IFS= read -r -d '' item; do
    # Get relative path
    relative_path="${item#./}"
    
    # Skip if it's the current directory
    if [ "$relative_path" = "." ]; then
        continue
    fi
    
    source_item="$SOURCE/$relative_path"
    target_item="$DEST/$relative_path"
    
    # Check if case-insensitive version exists in target
    existing_target=$(find_case_insensitive "$DEST" "$relative_path" || echo "")
    
    if [ -d "$source_item" ]; then
        # It's a directory
        if [ -n "$existing_target" ]; then
            # Directory exists (case-insensitively), use existing path
            : # Do nothing, directory already exists
        else
            # Create new directory with exact case from source
            mkdir -p "$target_item"
        fi
    else
        # It's a file
        if [ -n "$existing_target" ]; then
            # File exists (case-insensitively), overwrite it (keeping target's case)
            cp -f "$source_item" "$existing_target"
        else
            # File doesn't exist, create parent directories if needed and copy
            target_dir="$(dirname "$target_item")"
            
            # Check if parent directory exists (case-insensitively)
            parent_relative="$(dirname "$relative_path")"
            if [ "$parent_relative" != "." ]; then
                existing_parent=$(find_case_insensitive "$DEST" "$parent_relative" || echo "")
                if [ -n "$existing_parent" ]; then
                    # Parent exists with different case, use it
                    filename="$(basename "$target_item")"
                    target_item="$existing_parent/$filename"
                else
                    # Create parent directories
                    mkdir -p "$target_dir"
                fi
            fi
            
            cp "$source_item" "$target_item"
        fi
    fi
done < <(find . -print0 | sort -z)

echo "Copy completed: $SOURCE -> $DEST"
